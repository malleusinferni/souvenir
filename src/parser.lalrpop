use ast;
use tokenizer::{Tok, TokErr};

grammar<'input>(text: &'input str);

pub Module: ast::Module = {
    <s:Statement*> <k:Knot*> => ast::Module {
        globals: s,
        knots: k,
    },
};

Knot: ast::Knot = {
    "==" <name:FuncName> <args:ArgList?> ";" <body:Statement*> => ast::Knot {
        name: name,
        args: args.unwrap_or_else(|| vec![]),
        body: body,
    },
};

Statement: ast::Stmt = {
    "disarm" <Label> ";" => {
        ast::Stmt::Disarm(<>)
    },

    "weave" <l:Label?> ";" <body:Choice*> ";;" ";" => {
        ast::Stmt::Weave(l.unwrap_or(ast::Label::Anonymous), body)
    },

    "trap" <l:Label?> ";" <body:Trap*> ";;" ";" => {
        ast::Stmt::Trap(l.unwrap_or(ast::Label::Anonymous), body)
    },

    "listen" ";" <body:Trap*> ";;" ";" => {
        ast::Stmt::Listen(body)
    },

    "trace" <Expr> ";" => ast::Stmt::Trace(<>),

    <LitStr> ";" => ast::Stmt::Trace(<>),

    "let" <a:Assign> "=" <v:Expr> ";" => {
        ast::Stmt::Let(a, v)
    },

    "wait" <Expr> ";" => ast::Stmt::Wait(<>),

    <d:VarName> <m:Expr> ";" => {
        ast::Stmt::SendMsg(ast::Expr::Var(d), m)
    },

    <Expr> "<-" <Expr> ";" => ast::Stmt::SendMsg(<>),

    "->" <FnCall> ";" => ast::Stmt::Recur(<>),

    "spawn" <FnCall> ";" => {
        ast::Stmt::LetSpawn(ast::Assign::Hole, <>)
    },

    "let" <a:Assign> "=" "spawn" <f:FnCall> ";" => {
        ast::Stmt::LetSpawn(a, f)
    },

    ";" => ast::Stmt::Empty,
};

Choice: ast::Choice = {
    "|" <g:ChoiceGuard> <s:LitStr> ";" <body:Statement*> => ast::Choice {
        guard: g,
        title: s,
        body: body,
    },

    "|" "_" ";" <body:Statement*> => ast::Choice {
        guard: ast::Expr::LastResort,
        title: ast::Expr::Str(String::new()),
        body: body,
    }

    // TODO: Handle more complicated choice formats
};

#[inline]
ChoiceGuard: ast::Expr = {
    <g:("if" <Expr> "then")?> => g.unwrap_or_else(|| ast::Expr::from(true))
};

Trap: ast::Trap = {
    "|" <p:Pat> <o:TrapSrc> <g:TrapGuard> ";" <body:Statement*> => ast::Trap {
        pattern: p,
        guard: g,
        origin: o,
        body: body,
    },
};

#[inline]
TrapSrc: ast::Pat = {
    <o:("from" <Assign>)?> => {
        ast::Pat::Assign(o.unwrap_or_else(|| ast::Assign::Hole))
    }
};

#[inline]
TrapGuard: ast::Expr = {
    <g:("when" <Expr>)?> => g.unwrap_or_else(|| ast::Expr::from(true))
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

ArgList: Vec<ast::Var> = {
    "(" <Comma<VarName>> ")" => <>,
    "(" ")" => vec![],
};

FnCall: ast::FnCall = {
    <f:FuncName> "(" <a:Comma<Expr>?> ")" => {
        ast::FnCall(f, a.unwrap_or_else(|| vec![]))
    },

    <f:FuncName> => ast::FnCall(f, vec![]),
};

Label: ast::Label = {
    <s:"NmLabel"> => ast::Label::Local({
        s.chars().skip(1).collect::<String>()
    })
};

FuncName: ast::Label = {
    <p:(<"NmFunc"> ":")*> <s:"NmFunc"> => {
        let name = s.to_string();
        if p.is_empty() {
            ast::Label::Local(name)
        } else {
            let path = p.into_iter().map(|s| s.to_string()).collect();
            ast::Label::Qualified(ast::Modpath(path), name)
        }
    },
};

VarName: ast::Var = {
    <s:"NmVar"> => ast::Var::Name(s.to_string())
};

Assign: ast::Assign = {
    "_" => ast::Assign::Hole,

    <VarName> => ast::Assign::Var(<>),
};

Pat: ast::Pat = {
    <Assign> => ast::Pat::Assign(<>),

    "[" "]" => ast::Pat::List(vec![]),

    "[" <Comma<Pat>> "]" => ast::Pat::List(<>),

    <Literal> => ast::Pat::Literal(<>),
};

Expr: ast::Expr = {
    <VarName> => ast::Expr::Var(<>),
    <Literal> => ast::Expr::Literal(<>),
    // FIXME: Operators
};

Literal: ast::Lit = {
    <a:"LitAtom"> => ast::Lit::Atom({
        a.chars().skip(1).collect::<String>()
    }),

    <n:"LitInt"> => ast::Lit::Int({
        n.parse::<i32>().expect("Can't parse int")
    }),
};

LitStr: ast::Expr = {
    <s:"LitStr"> => ast::Expr::Str({
        s.chars().skip(2).collect::<String>()
    })
};

extern {
    type Location = usize;
    type Error = TokErr;

    enum Tok<'input> {
        ";" => Tok::EndLn,
        ";;" => Tok::EndBlk,

        "disarm" => Tok::KwDisarm,
        "from" => Tok::KwFrom,
        "given" => Tok::KwGiven,
        "if" => Tok::KwIf,
        "let" => Tok::KwLet,
        "listen" => Tok::KwListen,
        "spawn" => Tok::KwSpawn,
        "then" => Tok::KwThen,
        "trace" => Tok::KwTrace,
        "trap" => Tok::KwTrap,
        "wait" => Tok::KwWait,
        "weave" => Tok::KwWeave,
        "when" => Tok::KwWhen,

        "NmFunc" => Tok::NmFunc(<&'input str>),
        "NmLabel" => Tok::NmLabel(<&'input str>),
        "NmMacro" => Tok::NmMacro(<&'input str>),
        "NmVar" => Tok::NmVar(<&'input str>),

        "LitAtom" => Tok::LitAtom(<&'input str>),
        "LitInt" => Tok::LitInt(<&'input str>),
        "LitRoll" => Tok::LitRoll(<&'input str>),
        "LitStr" => Tok::LitStr(<&'input str>),

        "=" => Tok::OpAssign,
        "," => Tok::OpComma,
        "." => Tok::OpDot,
        "<-" => Tok::OpSend,
        ":" => Tok::OpColon,

        "*" => Tok::OpMul,
        "/" => Tok::OpDiv,
        "+" => Tok::OpAdd,
        "-" => Tok::OpSub,

        "|" => Tok::Pipe,
        "_" => Tok::Hole,
        "==" => Tok::Knot,
        "->" => Tok::Divert,

        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "[" => Tok::LSquare,
        "]" => Tok::RSquare,
        "{" => Tok::LCurly,
        "}" => Tok::RCurly,
        "<" => Tok::LAngle,
        ">" => Tok::RAngle,
    }
}

// vim: ft=rust
