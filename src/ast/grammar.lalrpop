use ast;

use ast::tokens::{Tok, TokErr};

grammar<'input>(text: &'input str);

pub Module: ast::Module = {
    <b:Block> <s:Scene*> => ast::Module {
        globals: b,
        scenes: s,
    },
};

Scene: ast::Scene = {
    "==" <name:"NmScene"> <args:ArgList?> ";" <body:Block> => ast::Scene {
        name: ast::SceneName {
            name: name.to_string(),
            in_module: None,
        },
        args: args.unwrap_or_default(),
        body: body,
    },
};

Block: ast::Block = {
    <Statement*> => ast::Block(<>),
};

Statement: ast::Stmt = {
    ";" => ast::Stmt::Empty,

    "disarm" <Label> ";" => {
        ast::Stmt::Disarm {
            target: <>,
        }
    },

    "weave" <name:Label?> ";" <arms:WeaveArm*> ";;" ";" => {
        ast::Stmt::Weave {
            name: name.unwrap_or_default(),
            arms: arms,
        }
    },

    "trap" <name:Label?> ";" <arms:TrapArm*> ";;" ";" => {
        ast::Stmt::Trap {
            name: name.unwrap_or_default(),
            arms: arms,
        }
    },

    "listen" <name:Label?> ";" <arms:TrapArm*> ";;" ";" => {
        ast::Stmt::Listen {
            name: name.unwrap_or_default(),
            arms: arms,
        }
    },

    "trace" <Expr> ";" => {
        ast::Stmt::Trace {
            value: <>,
        }
    },

    "let" <name:Ident> "=" <value:Expr> ";" => {
        ast::Stmt::Let {
            name: name,
            value: value,
        }
    },

    "wait" <Expr> ";" => {
        ast::Stmt::Wait {
            value: <>,
        }
    },

    <Str> ";" => {
        ast::Stmt::Naked {
            target: None,
            message: <>,
        }
    },

    <name:Ident> <message:Str> ";" => {
        ast::Stmt::Naked {
            target: Some(name),
            message: message,
        }
    },

    <target:Ident> "<-" <message:Comma<Expr>> ";" => {
        ast::Stmt::SendMsg {
            target: target,
            message: ast::Expr::List(message),
        }
    },

    "->" <Call> ";" => {
        ast::Stmt::Recur {
            target: <>,
        }
    },

    <name:("let" <Ident> "=")?> "spawn" <target:Call> ";" => {
        ast::Stmt::Let {
            name: name.unwrap_or_default(),
            value: ast::Expr::Spawn(target),
        }
    },
};

WeaveArm: ast::WeaveArm = {
    "|" <guard:WeaveGuard> <message:Str> ";" <body:Block> => {
        ast::WeaveArm {
            guard: guard,
            message: ast::Expr::Str(message),
            body: body,
        }
    },

    "|" "_" ";" <body:Block> => {
        ast::WeaveArm {
            guard: ast::Cond::LastResort,
            message: ast::Expr::Str(ast::Str::Plain("".to_owned())),
            body: body,
        }
    },

    // TODO: Handle more complicated choice formats
};

#[inline]
WeaveGuard: ast::Cond = {
    <guard:("if" <Cond> "then")?> => {
        guard.unwrap_or(ast::Cond::True)
    }
};

TrapArm: ast::TrapArm = {
    "|" <p:Pat> <o:TrapSender> <g:TrapGuard> ";" <body:Block> => {
        ast::TrapArm {
            pattern: p,
            origin: o,
            guard: g,
            body: body,
        }
    },
};

#[inline]
TrapSender: ast::Pat = {
    <sender:("from" <Ident>)?> => {
        ast::Pat::Id(sender.unwrap_or_default())
    }
};

#[inline]
TrapGuard: ast::Cond = {
    <guard:("when" <Cond>)?> => {
        guard.unwrap_or(ast::Cond::True)
    }
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

ArgList: Vec<ast::Ident> = {
    "(" <args:(Comma<Ident>)?> ")" => args.unwrap_or_default(),
};

Call: ast::Call = {
    <name:SceneName> <args:("(" <(Comma<Expr>)?> ")")?> => {
        ast::Call(name, args.unwrap_or(None).unwrap_or(vec![]))
    },
};

SceneName: ast::SceneName = {
    <path:Modpath?> <name:"NmScene"> => {
        ast::SceneName {
            name: name.to_string(),
            in_module: path,
        }
    },
};

Label: ast::Label = {
    <name:"NmLabel"> => ast::Label::Local {
        name: name.chars().skip(1).collect::<String>()
    },
};

Ident: ast::Ident = {
    <name:"NmVar"> => match name {
        "Self" => ast::Ident::PidOfSelf,

        name => ast::Ident::Var {
            name: name.to_string()
        },
    },

    "_" => ast::Ident::Hole,
};

#[inline]
Modpath: ast::Modpath = {
    <segments:(<"NmScene"> ":")+> => {
        ast::Modpath({
            segments.into_iter()
                .map(|s| s.to_owned())
                .collect()
        })
    },
};

Pat: ast::Pat = {
    <Ident> => ast::Pat::Id(<>),

    <Literal> => ast::Pat::Lit(<>),

    "[" <contents:(Comma<Pat>)?> "]" => {
        ast::Pat::List(contents.unwrap_or(vec![]))
    },
};

Cond: ast::Cond = {
    // FIXME: More operators
    <Expr> "==" <Expr> => ast::Cond::Eql(<>),
};

Expr: ast::Expr = {
    // FIXME: More operators
    <e:Expr2> => e,
};

Binop<O, L, R>: ast::Expr = {
    <lhs:L> <op:O> <rhs:R> => {
        ast::Expr::Op(op, vec![lhs, rhs])
    },
};

Op2: ast::Op = {
    "+" => ast::Op::Add,
    "-" => ast::Op::Sub,
};

Expr2: ast::Expr = {
    <b:Binop<Op2, Expr2, Expr1>> => b,
    <e:Expr1> => e,
};

Op1: ast::Op = {
    "/" => ast::Op::Div,
    "*" => ast::Op::Mul,
};

Expr1: ast::Expr = {
    <b:Binop<Op1, Expr1, Expr0>> => b,
    <e:Expr0> => e,
};

Expr0: ast::Expr = {
    <Ident> => ast::Expr::Id(<>),

    <Literal> => ast::Expr::Lit(<>),

    // TODO: String

    "(" <e:Expr> ")" => e,

    "[" <elems:(Comma<Expr>)?> "]" => {
        ast::Expr::List(elems.unwrap_or(vec![]))
    },
};

Literal: ast::Lit = {
    <a:"LitAtom"> => ast::Lit::Atom({
        a.chars().skip(1).collect::<String>()
    }),

    <n:"LitInt"> => ast::Lit::Int({
        n.parse::<i32>().expect("Can't parse int")
    }),
};

Str: ast::Str = {
    <s:"LitStr"> => ast::Str::Plain({
        s.chars().skip(2).collect::<String>()
    }),

    // TODO: Markup and interpolation
};

extern {
    type Location = usize;
    type Error = TokErr;

    enum Tok<'input> {
        ";" => Tok::EndLn,
        ";;" => Tok::EndBlk,

        "disarm" => Tok::KwDisarm,
        "from" => Tok::KwFrom,
        "given" => Tok::KwGiven,
        "if" => Tok::KwIf,
        "let" => Tok::KwLet,
        "listen" => Tok::KwListen,
        "spawn" => Tok::KwSpawn,
        "then" => Tok::KwThen,
        "trace" => Tok::KwTrace,
        "trap" => Tok::KwTrap,
        "wait" => Tok::KwWait,
        "weave" => Tok::KwWeave,
        "when" => Tok::KwWhen,

        "NmScene" => Tok::NmScene(<&'input str>),
        "NmLabel" => Tok::NmLabel(<&'input str>),
        "NmMacro" => Tok::NmMacro(<&'input str>),
        "NmVar" => Tok::NmVar(<&'input str>),

        "LitAtom" => Tok::LitAtom(<&'input str>),
        "LitInt" => Tok::LitInt(<&'input str>),
        "LitRoll" => Tok::LitRoll(<&'input str>),
        "LitStr" => Tok::LitStr(<&'input str>),

        "=" => Tok::OpAssign,
        "," => Tok::OpComma,
        "." => Tok::OpDot,
        "<-" => Tok::OpSend,
        ":" => Tok::OpColon,

        "*" => Tok::OpMul,
        "/" => Tok::OpDiv,
        "+" => Tok::OpAdd,
        "-" => Tok::OpSub,

        "|" => Tok::Pipe,
        "_" => Tok::Hole,
        "==" => Tok::Scene,
        "->" => Tok::Divert,

        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "[" => Tok::LSquare,
        "]" => Tok::RSquare,
        "{" => Tok::LCurly,
        "}" => Tok::RCurly,
        "<" => Tok::LAngle,
        ">" => Tok::RAngle,
    }
}

// vim: ft=rust
